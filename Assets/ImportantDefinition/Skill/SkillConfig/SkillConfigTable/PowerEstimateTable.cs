// This code automatically generated by TableCodeGen
using UnityEngine;
using System.Collections.Generic;
using Skill;
using System.IO;
using System.Text;
using HittingDetection;
using System;
using Cysharp.Threading.Tasks;

// 本结构唯一的作用是主界面略览技能详情的时候提供一个大概的数值，
// 任何已经登陆了的技能，如果在本表内没有条目，则会在技能详情画面报错。

public class PowerEstimateTable
{
	public class Row
	{
		public string RECORD_ID;
		public string REAL_NAME;
		public string SPLevel;
		public string EstimateDamage;
        public string AttackCount;
		public string HP;
	}

    private static readonly List<Row> rowList = new List<Row>();
    static bool isLoaded = false;
    
    public static async UniTask Save(string type)
    {
        Debug.Log("开始生成技能参数预估文件，等一阵子，开始可能没有反应。");
        var skillConfigs = SkillConfigTable.GetSkillConfigsOfType(type);
        var animDic = await SKillAnalyzer.AllSkillAnims(type);
        await Save(Application.dataPath + "/" +CommonSetting.SkillStaticAnalysis + ".csv", skillConfigs, animDic);
    }
    
    static async UniTask Save(string filepath, List<SkillConfig> skillConfigs, IDictionary<string, AnimationClip> animDic)
    {
        rowList.Clear();
        string[][] grid = new string[skillConfigs.Count + 1][];
        for (int i = 0; i < grid.Length; i++)
        {
            grid[i] = new string[6];
            if (i == 0)
            {
                grid[i][0] = "RECORD_ID";
                grid[i][1] = "REAL_NAME";
                grid[i][2] = "SPLevel";
                grid[i][3] = "EstimateDamage";
                grid[i][4] = "AttackCount";
                grid[i][5] = "HP";
            }
            else
            {
                grid[i][0] = skillConfigs[i - 1].RECORD_ID;
                grid[i][1] = skillConfigs[i - 1].REAL_NAME;
                grid[i][2] = skillConfigs[i - 1].SP_LEVEL.ToString();
                animDic.TryGetValue(skillConfigs[i -1].REAL_NAME, out var clip);
                if (clip == null)
                {
                    Debug.Log("no anim clip :"+ skillConfigs[i -1].REAL_NAME);
                    continue;
                }
                var pair = await ATCal(clip, skillConfigs[i - 1].ATTACK_WEIGHT);
                grid[i][3] = pair.Item1.ToString();
                grid[i][4] = pair.Item2.ToString();
                grid[i][5] = skillConfigs[i - 1].HP_WEIGHT.ToString();
                
                var row = new Row
                {
                    RECORD_ID = grid[i][0],
                    REAL_NAME = grid[i][1],
                    SPLevel = grid[i][2],
                    EstimateDamage = grid[i][3],
                    AttackCount = grid[i][4],
                    HP = grid[i][5]
                };
                rowList.Add(row);
            }
        }
        
        var delimiter = ",";
        var sb = new StringBuilder();
        foreach (var t in grid)
            sb.AppendLine(string.Join(delimiter, t));
        Debug.Log("Try saving file:" + filepath);
        var outStream = File.CreateText(filepath);
        outStream.WriteLine(sb);
        outStream.Close();
    }
    
    public static async UniTask LoadFile()
    {
        //暂时做如下处理
        var csv = await AddressablesLogic.LoadT<TextAsset>("Config/" + CommonSetting.SkillStaticAnalysis);
        if (csv)
        {
            Load(csv.text);
        }
        else
            Debug.Log("没能读取到技能数值参考文件。"+CommonSetting.SkillStaticAnalysis);
    }
    
    static void Load(string text)
	{
		rowList.Clear();
		var grid = CsvParser2.Parse(text);
        try
        {
            for(var i = 1 ; i < grid.Length ; i++)
            {
                if (grid[i].Length == 6) // 程序似乎会把最后的空行也读取所以需这个check
                {
                    var row = new Row
                    {
                        RECORD_ID = grid[i][0],
                        REAL_NAME = grid[i][1],
                        SPLevel = grid[i][2],
                        EstimateDamage = grid[i][3],
                        AttackCount = grid[i][4],
                        HP = grid[i][5]
                    };
                    rowList.Add(row);
                }
            }
            isLoaded = true;
        }
        catch (Exception e)
        {
            Debug.Log(e);
        }
	}
    
	public static Row Find_RECORD_ID(string find)
	{
		return rowList.Find(x => x.RECORD_ID == find);
	}
    
    static async UniTask<(float, int) > ATCal(AnimationClip clip, float skillATRef)
    {
        int attackCount = 0;
        float amount = 0;
        for (int i = 0; i < clip.events.Length; i++)
        {
            #region 拳脚攻击
            if (SKillAnalyzer.AttackFrameStartMethodNames.Contains(clip.events[i].functionName) && clip.events[i].intParameter != 0)
            {
                amount += skillATRef;
                attackCount++;
            }
            if (clip.events[i].functionName == "SetAllBodyMarkerManagersIn")
            {
                amount += skillATRef;
                attackCount++;
            }
            if (clip.events[i].functionName == "ClearTargets")
            {
                amount += skillATRef;
                attackCount++;
            }
            if (clip.events[i].functionName == "EnableMarkers")
            {
                amount += skillATRef;
                attackCount++;
            }
            #endregion
                        
            #region MagicForward
            if (clip.events[i].functionName == "MagicForward" || clip.events[i].functionName == "MagicToEnemy")
            {
                var magicObjectName = clip.events[i].stringParameter;
                var hurtObject = await AddressablesLogic.LoadObject("defaultmagic/" + magicObjectName + ".prefab");
                var hitBox = hurtObject.GetComponent<HitBoxManager>();
                if (hitBox == null)
                {
                    Debug.Log("请检查这个技能动画:" + clip.name + ",与此伤害物体：" + magicObjectName);
                }
                amount += hitBox.AT_weight * skillATRef;
                attackCount++;
                
                var decomposition = hurtObject.GetComponent<Decomposition>();
                if (decomposition.Attachments.Length > 0)
                {
                    Debug.Log("技能动画："+clip.name + " 不好机械评估");
                    return (-999f, attackCount);
                }
                
                //// 顺便检查attachment，与攻击力预估无关 /////
                for (int z = 0; z < decomposition.Attachments.Length; z++)
                {
                    var attachment = await AddressablesLogic.LoadObject("defaultmagic/" + decomposition.Attachments[z]+ ".prefab");
                    var attachments = attachment.GetComponent<HitBoxManager>();
                    if (attachments == null)
                    {
                        Debug.Log("请检查这个技能动画:" + clip.name + ",与此伤害物体：" + magicObjectName + "其附属物件资源"+ decomposition.Attachments[z] + "不存在");
                    }
                }
                ///////////////////////////////////////////
            }
            #endregion
            
            #region 几个固定魔法
            if (clip.events[i].functionName == "Bullet_shoot_from_body_part" || clip.events[i].functionName == "BlastAttack")
            {
                amount += skillATRef;
                attackCount++;
            }
            #endregion
            
            if (clip.events[i].functionName == "PrepareOneMagic")
            {
                var magicObjectName = clip.events[i].stringParameter;
                var hurtObject = await AddressablesLogic.LoadObject("defaultmagic/" + magicObjectName+ ".prefab");
                var hitBox = hurtObject.GetComponent<HitBoxManager>();
                var oneDamage = hitBox.AT_weight * skillATRef;
                var decomposition = hurtObject.GetComponent<Decomposition>();
                if (decomposition.Attachments.Length > 0)
                {
                    Debug.Log("技能动画："+clip.name + " 不好机械评估");
                    return (-999f, attackCount);
                }
                
                //// 顺便检查attachment，与攻击力预估无关 /////
                for (int z = 0; z < decomposition.Attachments.Length; z++)
                {
                    var attachment = await AddressablesLogic.LoadObject("defaultmagic/" + decomposition.Attachments[z]+ ".prefab");
                    var attachments = attachment.GetComponent<HitBoxManager>();
                    if (attachments == null)
                    {
                        Debug.Log("请检查这个技能动画:" + clip.name + ",与此伤害物体：" + magicObjectName + "其附属物件资源"+ decomposition.Attachments[z] + "不存在");
                    }
                }
                ///////////////////////////////////////////
                
                for (var y = i + 1; y < clip.events.Length; y++)
                {
                    if (clip.events[y].functionName == "ReleasePreparedMagic" || clip.events[y].functionName == "ReleasePreparedMagicToAir")
                    {
                        //Debug.Log(_clip.name + ":" + _clip.events[y].functionName + "伤害估值增加："+ oneDamege);
                        amount += oneDamage;
                        attackCount++;
                    }
                    // 第二次遇到PrepareOneMagic说明换魔法了。一个技能两次PrepareOneMagic目前其实还没有
                    if (clip.events[y].functionName == "PrepareOneMagic")
                    {
                        Debug.Log(clip.name + "出现两次PrepareOneMagic");
                        break;
                    }
                }
            }
        }
        return (amount, attackCount);
    }
}