// This code automatically generated by TableCodeGen
using UnityEngine;
using Soul;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Log
{
    public class HitBoxLogTable
    {
        static HitBoxLogTable instance;
        public static HitBoxLogTable Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new HitBoxLogTable();
                }
                return instance;
            }
        }
        
        public void SkillLog(List<Data_Center> members)
        {
            var singleFightLogs = new List<SingleFightLog>();
            for (var i = 0; i < members.Count; i++)
            {
                if (members[i] != null)
                {
                    singleFightLogs.Add(members[i]._MyBehaviorRunner.SingleFightLog);
                }
            }
            
            if (FightGlobalSetting.HitBoxLogger)
            {
                Instance.Load(HitBoxLogger.Instance.LoadCurrentToString());
                HitBoxLogger.Instance.LogSummit();
                foreach (var t in singleFightLogs)
                {
                    t.Summary();
                }
                Instance.SaveByCurrentRows_HitBoxLog(Application.persistentDataPath + "/" + CommonSetting.SkillDynamicAnalysis, HitBoxLogger.Instance, singleFightLogs);
                for (var i = 0; i < singleFightLogs.Count; i++)
                {
                    singleFightLogs[i].Clear();
                }
                HitBoxLogger.Instance.Clear();
            }
        }

        public class Row
        {
            public string RECORD_ID;
            public string REAL_NAME;
            public string MONSTER_TYPE;
            public string Untouched;
            public string Touched;
            public string Succeeded;
            public string TriggeredTimes;
            public string InterruptedTimes;
        }

        public List<Row> rowList = new List<Row>();
        bool isLoaded = false;

        public bool IsLoaded()
        {
            return isLoaded;
        }
        
        public void Load(TextAsset csv)
        {
            rowList.Clear();
            string[][] grid = CsvParser2.Parse(csv.text);
            for (int i = 1; i < grid.Length; i++)
            {
                var row = new Row
                {
                    RECORD_ID = grid[i][0],
                    REAL_NAME = grid[i][1],
                    MONSTER_TYPE = grid[i][2],
                    Untouched = grid[i][3],
                    Touched = grid[i][4],
                    Succeeded = grid[i][5],
                    TriggeredTimes = grid[i][6],
                    InterruptedTimes = grid[i][7]
                };
                rowList.Add(row);
            }
            isLoaded = true;
        }

        void Load(string csv)
        {
            rowList.Clear();
            string[][] grid = CsvParser2.Parse(csv);
            for (int i = 1; i < grid.Length; i++)
            {
                if (grid[i].Length == 0)
                {
                    continue;
                }
                Row row = new Row
                {
                    RECORD_ID = grid[i][0],
                    REAL_NAME = grid[i][1],
                    MONSTER_TYPE = grid[i][2],
                    Untouched = grid[i][3],
                    Touched = grid[i][4],
                    Succeeded = grid[i][5],
                    TriggeredTimes = grid[i][6],
                    InterruptedTimes = grid[i][7]
                };
                rowList.Add(row);
            }
            isLoaded = true;
        }

        public void SaveByCurrentRows_HitBoxLog(string filePath, HitBoxLogger hitBoxLogger, List<SingleFightLog> singleFightLogs)
        {
            IDictionary<string, int> StateTriggerTimes_whole = new Dictionary<string, int>();
            IDictionary<string, int> StateInterruptedTimes_whole = new Dictionary<string, int>();

            if (singleFightLogs == null)
                goto A;

            for (int index = 0; index < singleFightLogs.Count; index++)
            {
                var stateTriggerTimes = singleFightLogs[index].StateTriggerdTimes;
                var one_interruptedTimes = singleFightLogs[index].StateInterruptedTimes;

                foreach (var keyValuePair in stateTriggerTimes)
                {
                    if (!StateTriggerTimes_whole.ContainsKey(keyValuePair.Key))
                    {
                        StateTriggerTimes_whole.Add(keyValuePair);
                    }
                    else
                    {
                        StateTriggerTimes_whole[keyValuePair.Key] += keyValuePair.Value;
                    }
                }

                foreach (var keyValuePair in one_interruptedTimes)
                {
                    if (!StateInterruptedTimes_whole.ContainsKey(keyValuePair.Key))
                    {
                        StateInterruptedTimes_whole.Add(keyValuePair);
                    }
                    else
                    {
                        StateInterruptedTimes_whole[keyValuePair.Key] += keyValuePair.Value;
                    }
                }
            }
            
            A:
            
            var toDeleteList = new List<Row>();
            foreach (Row row in rowList)
            {
                if (row.REAL_NAME == null)
                    toDeleteList.Add(row);
            }
            foreach (Row row in toDeleteList)
            {
                Debug.Log("由于原先行的一些问题将之予以删除：" + rowList.IndexOf(row));
                rowList.Remove(row);
            }

            string[][] grid = new string[rowList.Count + 1][];
            for (int i = 0; i < grid.Length; i++)
            {
                grid[i] = new string[12];
                if (i == 0)
                {
                    grid[i][0] = "RECORD_ID";
                    grid[i][1] = "REAL_NAME";
                    grid[i][2] = "MONSTER_TYPE";
                    grid[i][3] = "Untouched(未触摸到敌人的hitbox数量)";
                    grid[i][4] = "Touched(触摸到敌人但没造成伤害的hitbox数量)";
                    grid[i][5] = "Successed(成功击中敌人的hitbox数量)";
                    grid[i][6] = "TriggerdTimes(技能使用次数）";
                    grid[i][7] = "InteruptedTimes（技能被打断次数）";
                }
                else
                {
                    if (hitBoxLogger == null)
                    {
                        grid[i][0] = rowList[i - 1].RECORD_ID;
                        grid[i][1] = rowList[i - 1].REAL_NAME;
                        grid[i][2] = rowList[i - 1].MONSTER_TYPE;
                        grid[i][3] = "0";
                        grid[i][4] = "0";
                        grid[i][5] = "0";
                        grid[i][6] = "0";
                        grid[i][7] = "0";

                    }
                    else
                    {
                        grid[i][0] = rowList[i - 1].RECORD_ID;
                        grid[i][1] = rowList[i - 1].REAL_NAME;
                        grid[i][2] = rowList[i - 1].MONSTER_TYPE;
                        grid[i][3] = ((hitBoxLogger.untouchedtimes.ContainsKey(grid[i][1]) ? hitBoxLogger.untouchedtimes[grid[i][1]] : 0) + int.Parse(rowList[i - 1].Untouched)).ToString();
                        grid[i][4] = ((hitBoxLogger.touchedtimes.ContainsKey(grid[i][1]) ? hitBoxLogger.touchedtimes[grid[i][1]] : 0) + int.Parse(rowList[i - 1].Touched)).ToString();
                        grid[i][5] = ((hitBoxLogger.successedtimes.ContainsKey(grid[i][1]) ? hitBoxLogger.successedtimes[grid[i][1]] : 0) + int.Parse(rowList[i - 1].Succeeded)).ToString();
                        grid[i][6] = ((StateTriggerTimes_whole.ContainsKey(grid[i][1]) ? StateTriggerTimes_whole[grid[i][1]] : 0) + int.Parse(rowList[i - 1].TriggeredTimes)).ToString();
                        grid[i][7] = ((StateInterruptedTimes_whole.ContainsKey(grid[i][1]) ? StateInterruptedTimes_whole[grid[i][1]] : 0) + int.Parse(rowList[i - 1].InterruptedTimes)).ToString();
                    }
                }
            }
            var delimiter = ",";
            var sb = new StringBuilder();
            for (var index = 0; index < grid.Length; index++)
                sb.AppendLine(string.Join(delimiter, grid[index]));
            Debug.Log("尝试最终保存文件" + filePath);
            var outStream = File.CreateText(filePath);
            outStream.WriteLine(sb);
            outStream.Close();
        }
    }
}